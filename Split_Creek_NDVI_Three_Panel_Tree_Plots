/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-85.95403899512176, 35.22128753226473],
          [-85.95560640507541, 35.21519867481589],
          [-85.9554776590427, 35.21496200940493],
          [-85.95495194607578, 35.21511978642223],
          [-85.95338553601108, 35.21546163557435],
          [-85.95202297383152, 35.215952493377735],
          [-85.95131487065159, 35.21659235712915],
          [-85.94957679920994, 35.21709197326388],
          [-85.94839662724338, 35.21705691258283],
          [-85.94835371189914, 35.21728480673899],
          [-85.94698042088352, 35.222573650426604],
          [-85.94696969204746, 35.22362539277859],
          [-85.94736665898166, 35.22431778238637],
          [-85.9484180849155, 35.224449248100264],
          [-85.9496411722263, 35.22374809516508],
          [-85.95174589731168, 35.22244065140694],
          [-85.9518209991641, 35.22199365604728],
          [-85.9538380203433, 35.221467776001525]]]),
    domain = ee.FeatureCollection("projects/servir-sco-assets/assets/Rx_Fire/Vector_Data/Sewanee_Domain"),
    imageVisParam = {"opacity":1,"bands":["NDVI"],"min":0.15867021679878235,"max":0.3921968340873718,"palette":["ffffff","ce7e45","df923d","f1b555","fcd163","99b718","74a901","66a000","529400","3e8601"]},
    imageVisParam2 = {"opacity":1,"bands":["NDVI"],"min":0.38497626781463623,"max":0.8589439988136292,"palette":["ffffff","ce7e45","df923d","f1b555","fcd163","99b718","74a901","66a000","529400","3e8601"]},
    imageVisParam3 = {"opacity":1,"bands":["NDVI"],"min":0.1310344785451889,"max":0.532608687877655,"palette":["ffffff","ce7e45","df923d","f1b555","fcd163","99b718","74a901","66a000","529400","3e8601"]};
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Modified by T. Mayer 8/6/25 NASA EarthRISE Sewanee Colab
///
/////////////////////////////////////////////////////////////////////////////////////////////////////////

var startDate = '2021-01-01'
var endDate = '2021-12-31'

Map.addLayer(domain, {}, "Domain bounds",false)
Map.centerObject(domain, 14)
var ndviVisDetailed = {
  min: -1,
  max: 1,
  palette: [
    'FFFFFF', // White (for very low or no vegetation)
    'CE7E45', // Light brown
    'DF923D', // Orange-brown
    'F1B555', // Yellowish-brown
    'FCD163', // Light yellow
    '99B718', // Light green
    '74A901', // Green
    '66A000', // Darker green
    '529400', // Even darker green
    '3E8601', // Darkest green (for high vegetation)
  ]
};

///////////////
// Your FeatureCollection
var fc = ee.FeatureCollection('projects/servir-sco-assets/assets/Rx_Fire/Vector_Data/Split_Creek_Ob')
// print(fc)
// Get distinct species names as a server-side list
var speciesList = fc.aggregate_array('Species').distinct();

// Print the list to the console (this will show the unique species)
// print('Unique Species:', speciesList);

// To bring the list client-side (Array of strings), use .getInfo() carefully:
// Note: .getInfo() is synchronous and should be used for small lists only.
speciesList.getInfo(function(list) {
  // print('Species list (client-side):', list);
});


var speciesToColor = ee.Dictionary({
  'Black Cherry': '#990000',
  'Black Oak': '#3B2F2F',
  'Chestnut Oak': '#954535',
  'Dead Standing': '#808080',
  'Pale Hickory': '#EEE8AA',
  'Red Maple': '#FF0000',
  'Scarlet Oak': '#FF2400',
  'Sourwood': '#6A0DAD',
  'Tulip Poplar': '#9ACD32',
  'White Oak': '#FFFFFF'
});

var defaultColor = '#999999';  // Gray for unknown/missing species

var styleFeature = function(feature) {
  var species = feature.get('Species');
  // If species is null or empty string, use defaultColor
  var color = ee.Algorithms.If(
    ee.Algorithms.IsEqual(species, null),
    defaultColor,
    ee.Algorithms.If(
      ee.String(species).length().eq(0),
      defaultColor,
      speciesToColor.get(species, defaultColor)
    )
  );
  
  var style = {color: color, width: 2};
  return feature.set('style', style);
};

var styledFc = fc.map(styleFeature);

var filteredFc = fc.filter(ee.Filter.neq('Species', null)).map(function(f) {
  var species = ee.String(f.get('Species')).trim();
  return f.set('Species', species);
}).filter(ee.Filter.neq('Species', ''));


// Map.addLayer(styledFc.style({styleProperty: 'style'}), {}, 'Species colored features');
////////////////




// Create three separate map panels
var leftMap = ui.Map();
var centerMap = ui.Map();
var rightMap = ui.Map();


// // Set initial center and zoom
// var initCenter = ee.Geometry.Point([-85.95, 35.22]);
// leftMap.setCenter(0, 0, 2);
// centerMap.setCenter(0, 0, 2);
// rightMap.setCenter(0, 0, 2);



// Get the centroid as an ee.Geometry.Point
var domainCentroid = geometry.centroid();

// Evaluate coordinates and center the maps
domainCentroid.coordinates().getInfo(function(coords) {
  var lon = coords[0];
  var lat = coords[1];

  leftMap.setCenter(lon, lat, 14);
  centerMap.setCenter(lon, lat, 14);
  rightMap.setCenter(lon, lat, 14);
});

leftMap.setOptions('SATELLITE');
centerMap.setOptions('SATELLITE');
rightMap.setOptions('SATELLITE');




////////////////////////////////////////////////////////////////////////////////////////

var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .filterDate(startDate, endDate) // Filter for dates between Jan 1, 2018 and Jan 1, 2023.
  .filterBounds(geometry) // Filter by the defined point.
  .filterMetadata('CLOUD_COVER', 'less_than', 20); // Filter for images with less than 20% cloud cover.

var ls_scale = collection.first().projection().nominalScale();
print('Nominal scale of the ls_scale (meters):', ls_scale); 

function maskL7L8(image) {
  //Bits 3 and 5 are cloud shadow and cloud, respectively.
  var cloudShadowBitMask = (1 << 4);
  var cloudsBitMask = (1 << 3);
  // Get the pixel QA band.
  var qa = image.select('QA_PIXEL');
  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0)
               .and(qa.bitwiseAnd(cloudsBitMask).eq(0));
  return image.updateMask(mask);
}

collection.map(maskL7L8)

// 3. Create a function to add an NDVI band
var addNDVI = function(image) {
  var ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI'); // NIR band is B5, Red band is B4 for Landsat 8.
  return image.addBands(ndvi);
};

// Apply the function to the image collection
var withNDVI = collection.map(addNDVI)

var ls_image = withNDVI.median().clip(geometry)

/////////////
// Create the chart
var chart = ui.Chart.image.series({ // Charting an image time series.
  imageCollection: withNDVI.select('NDVI'), // Select the NDVI band for the chart.
  region: geometry, // Chart data at the defined point.
  reducer: ee.Reducer.mean(), // Calculate the mean NDVI within the region.
  scale: 30 // Scale in meters for the reducer.
});

// Set chart options and display
chart.setOptions({ // Customize chart appearance.
  title: 'LS NDVI over time across the split creek watershed',
  vAxis: {title: 'NDVI'}, // Y-axis label.
  hAxis: {title: 'Date', format: 'YYYY-MM-dd'}, // X-axis label and format.
  lineWidth: 2, // Line width.
  pointSize: 3 // Point size.
});

//////////////////////////////////////////////////////////////////////////////////////////////////

var s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                  .filterDate(startDate, endDate)
                  // Pre-filter to get less cloudy granules.
                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE',20)).filterBounds(geometry);
                  // .map(maskS2clouds);

var s2_scale = s2.first().select('B4').projection().nominalScale();
print('Nominal scale of the s2_scale (meters):', s2_scale); 

function maskS2clouds(image) {
  var qa = image.select('QA60');

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000).copyProperties(image, image.propertyNames());
}

var s2 = s2.map(maskS2clouds);


var addNDVI = function(image) {
  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI');
  return image.addBands(ndvi);
};

// Apply the NDVI function to the image collection.
var s2withNDVI = s2.map(addNDVI);

var s2_image = s2withNDVI.median().clip(geometry)

////////

var chart_s2 = ui.Chart.image.series({
  imageCollection: s2withNDVI.select('NDVI'), // Select the 'NDVI' band for charting.
  region: geometry, // Use your defined region of interest.
  reducer: ee.Reducer.mean(), // Calculate the mean NDVI within the ROI for each image.
  scale: 10 // Sentinel-2's resolution is 10 meters, so we use that as the scale.
});


chart_s2.setOptions({
  title: 'Sentinel-2 NDVI over time across the split creek watershed',
  vAxis: {title: 'NDVI'},
  hAxis: {title: 'Date', format: 'YYYY-MM-dd'},
  lineWidth: 1,
  pointSize: 3,
  colors: ['e37d05']
});


/////////////////////////////////////////////////////////////////////////////////////////////////

var naip = ee.ImageCollection('USDA/NAIP/DOQQ').filterDate(startDate, endDate).filterBounds(geometry);
var naip_scale = naip.first().projection().nominalScale();
print('Nominal scale of the naip_scale (meters):', naip_scale); 

// 3. Create a function to add an NDVI band
var addNDVI = function(image) {
  var ndvi = image.normalizedDifference(['N', 'R']).rename('NDVI'); // NIR band is B5, Red band is B4 for Landsat 8.
  return image.addBands(ndvi).copyProperties(image, image.propertyNames());
};

// Apply the function to the image collection
var NAIPwithNDVI = naip.map(addNDVI); // Apply the addNDVI function to every image in the collection.


var NAIP_image = NAIPwithNDVI.median().clip(geometry)
////

var naipchart = ui.Chart.image.series({ // Charting an image time series.
  imageCollection: NAIPwithNDVI.select('NDVI'), // Select the NDVI band for the chart.
  region: geometry, // Chart data at the defined point.
  reducer: ee.Reducer.mean(), // Calculate the mean NDVI within the region.
  scale:1 // Scale in meters for the reducer.
});



naipchart.setOptions({ // Customize chart appearance.
  title: 'NAIP NDVI over time across the split creek watershed',
  vAxis: {title: 'NDVI'}, // Y-axis label.
  hAxis: {title: 'Date', format: 'YYYY-MM-dd'}, // X-axis label and format.
  lineWidth: 2, // Line width.
  pointSize: 3 // Point size.
});
///////////////////////////////////////////////////////////////////////////////////////////////
print("Temporal range of analysis:", startDate,  endDate)
print("Note NDVI is a median composite bounded by start and end dates adjust as needed")
print("Note the spatial resolution and temporal resolution trade offs displayed in the NDVI trend graphs")
print("Color ramps applied with a gamma 100% stretch [range -1 to 1]")
/////////////////////////////////////////////////////////////////////////////////////////////////


// Add layers to respective maps
leftMap.addLayer(ls_image.select('NDVI'), imageVisParam, 'NDVI ls annual median composite cloud filtered');  //imageVisParam  //ndviVisDetailed
leftMap.addLayer(styledFc.style({styleProperty: 'style'}), {}, 'Species colored features');
centerMap.addLayer(s2_image.select('NDVI'), imageVisParam2, 'NDVI S2 annual median composite cloud filtered');
centerMap.addLayer(styledFc.style({styleProperty: 'style'}), {}, 'Species colored features');
rightMap.addLayer(NAIP_image.select('NDVI'), imageVisParam, 'NDVI NAIP ls annual median composite cloud filtered');
rightMap.addLayer(styledFc.style({styleProperty: 'style'}), {}, 'Species colored features');

// Link map controls (optional sync)
var linker = ui.Map.Linker([leftMap, centerMap, rightMap]);

// Create a three-panel horizontal layout
// var panel = ui.Panel([
//   ui.Panel([leftMap], null, {stretch: 'both'}),
//   ui.Panel([centerMap], null, {stretch: 'both'}),
//   ui.Panel([rightMap], null, {stretch: 'both'})
// ], ui.Panel.Layout.Flow('horizontal'), {stretch: 'both'});


// Create vertical panels: each with a map and corresponding chart
var leftPanel = ui.Panel([
  ui.Label('Landsat 8 NDVI', {fontWeight: 'bold'}),
  leftMap,
  chart
], ui.Panel.Layout.Flow('vertical'), {stretch: 'both'});

var centerPanel = ui.Panel([
  ui.Label('Sentinel-2 NDVI', {fontWeight: 'bold'}),
  centerMap,
  chart_s2
], ui.Panel.Layout.Flow('vertical'), {stretch: 'both'});

var rightPanel = ui.Panel([
  ui.Label('NAIP NDVI', {fontWeight: 'bold'}),
  rightMap,
  naipchart
], ui.Panel.Layout.Flow('vertical'), {stretch: 'both'});

// Combine into the main horizontal panel
var panel = ui.Panel([
  leftPanel,
  centerPanel,
  rightPanel
], ui.Panel.Layout.Flow('horizontal'), {stretch: 'both'});
///////////////////////////////////////////////////////////////////////////

print('Charting of NDVI across all EO, bounded by time, per species')
///Chart per NDVI per speices

// Assuming your NDVI images are defined like this:
var sources = {
  LS: ls_image,
  S2: s2_image,
  NAIP: NAIP_image
};

// Step 1: Harmonize species property name to 'species'
filteredFc = filteredFc.map(function(f) {
  return f.set('species', f.get('Species'));
});

// Step 2: Sample NDVI from each image and attach metadata
var combinedSamples = ee.FeatureCollection([]);

Object.keys(sources).forEach(function(sourceKey) {
  var ndviImage = sources[sourceKey];

  var sampled = ndviImage.sampleRegions({
    collection: filteredFc,
    scale: 1, // Use appropriate scale per sensor: LS=30, S2=10, NAIP=1
    geometries: false
  }).map(function(f) {
    return f.set({
      source: sourceKey,
      species: f.get('species') // Ensures 'species' is retained
    });
  });

  combinedSamples = combinedSamples.merge(sampled);
});

// Step 3: Create chart (ColumnChart: NDVI by species, grouped by source)
var chart = ui.Chart.feature.groups({
  features: combinedSamples,
  xProperty: 'species',
  yProperty: 'NDVI',  // Change if NDVI band is named differently
  seriesProperty: 'source'
})
.setChartType('ColumnChart')
.setOptions({
  title: 'NDVI by Species and Source',
  hAxis: {title: 'Species'},
  vAxis: {title: 'NDVI'},
  legend: {position: 'top'},
  height: 500
});

print(chart);


///////////////////////////////////////////////////////////////////////////

// Set the UI root
ui.root.clear();
ui.root.add(panel);

////////////////////////////////////////////////////////////////////////////

// Container for both NDVI and Species legends
var legendContainer = ui.Panel({
  layout: ui.Panel.Layout.Flow('vertical'),
  style: {
    position: 'bottom-right',
    padding: '0px',
    margin: '0px',
    backgroundColor: 'rgba(255, 255, 255, 0)', // transparent to show individual panel backgrounds
  }
});

// NDVI Legend Panel
var ndviLegend = ui.Panel({
  style: {
    padding: '8px 15px',
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    border: '1px solid black',
    maxHeight: '250px',
    width: '140px'
  }
});

// NDVI Legend title
var legendTitle = ui.Label({
  value: 'NDVI Legend',
  style: {fontWeight: 'bold', margin: '0 0 4px 0', fontSize: '12px'}
});
ndviLegend.add(legendTitle);

// Palette and corresponding labels
var palette = ndviVisDetailed.palette;
var names = ['No Veg', 'Very Low', 'Low', 'Mod-Low', 'Mod', 'Mod-High', 'High', 'V. High', 'Dense', 'Max Veg'];

for (var i = 0; i < palette.length; i++) {
  var colorBox = ui.Label({
    style: {
      backgroundColor: '#' + palette[i],
      padding: '8px',
      margin: '0 4px 0 0'
    }
  });

  var description = ui.Label({
    value: names[i],
    style: {margin: '0 0 4px 0', fontSize: '11px'}
  });

  var legendItem = ui.Panel({
    widgets: [colorBox, description],
    layout: ui.Panel.Layout.Flow('horizontal')
  });

  ndviLegend.add(legendItem);
}

// Add NDVI legend to container
legendContainer.add(ndviLegend);

// Species Legend Panel
var speciesLegend = ui.Panel({
  style: {
    padding: '8px 15px',
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    border: '1px solid black',
    maxHeight: '300px',
    width: '140px',
    margin: '4px 0 0 0'
  }
});

var speciesLegendTitle = ui.Label({
  value: 'Species Legend',
  style: {fontWeight: 'bold', margin: '0 0 4px 0', fontSize: '12px'}
});
speciesLegend.add(speciesLegendTitle);

// Populate species legend
speciesToColor.evaluate(function(dict) {
  Object.keys(dict).forEach(function(key) {
    var colorBox = ui.Label({
      style: {
        backgroundColor: dict[key],
        padding: '8px',
        margin: '0 4px 0 0'
      }
    });

    var description = ui.Label({
      value: key,
      style: {margin: '0 0 4px 0', fontSize: '11px'}
    });

    var legendItem = ui.Panel({
      widgets: [colorBox, description],
      layout: ui.Panel.Layout.Flow('horizontal')
    });

    speciesLegend.add(legendItem);
  });

  // Add species legend below NDVI legend
  legendContainer.add(speciesLegend);
});

// Add combined legend container to the root
ui.root.add(legendContainer);
////////////////////////////////////

///////////
//Commented off code for charitgn species or NDVI indidvidually 

// // Floating NDVI Legend
// var legend = ui.Panel({
//   style: {
//     position: 'bottom-right',
//     padding: '8px 15px',
//     backgroundColor: 'rgba(255, 255, 255, 0.8)',
//     border: '1px solid black',
//     maxHeight: '250px',
//     width: '120px'
//   }
// });

// // Legend title
// var legendTitle = ui.Label({
//   value: 'NDVI Legend',
//   style: {fontWeight: 'bold', margin: '0 0 4px 0', fontSize: '12px'}
// });
// legend.add(legendTitle);

// // Palette and corresponding labels
// var palette = ndviVisDetailed.palette;
// var names = ['No Veg', 'Very Low', 'Low', 'Mod-Low', 'Mod', 'Mod-High', 'High', 'V. High', 'Dense', 'Max Veg'];

// for (var i = 0; i < palette.length; i++) {
//   var colorBox = ui.Label({
//     style: {
//       backgroundColor: '#' + palette[i],
//       padding: '8px',
//       margin: '0 4px 0 0'
//     }
//   });

//   var description = ui.Label({
//     value: names[i],
//     style: {margin: '0 0 4px 0', fontSize: '11px'}
//   });

//   var legendItem = ui.Panel({
//     widgets: [colorBox, description],
//     layout: ui.Panel.Layout.Flow('horizontal')
//   });

//   legend.add(legendItem);
// }

// // Add to the UI root (outside map panels)
// ui.root.add(legend);

// /////////////
// // Species Legend Panel
// var speciesLegend = ui.Panel({
//   style: {
//     position: 'bottom-right',
//     padding: '8px 15px',
//     backgroundColor: 'rgba(255, 255, 255, 0.8)',
//     border: '1px solid black',
//     maxHeight: '300px',
//     width: '150px',
//     margin: '5px 0 0 0'
//   }
// });

// // Legend title
// var speciesLegendTitle = ui.Label({
//   value: 'Species Legend',
//   style: {fontWeight: 'bold', margin: '0 0 4px 0', fontSize: '12px'}
// });
// speciesLegend.add(speciesLegendTitle);

// // Add each species with corresponding color
// speciesToColor.evaluate(function(dict) {
//   Object.keys(dict).forEach(function(key) {
//     var colorBox = ui.Label({
//       style: {
//         backgroundColor: dict[key],
//         padding: '8px',
//         margin: '0 4px 0 0'
//       }
//     });

//     var description = ui.Label({
//       value: key,
//       style: {margin: '0 0 4px 0', fontSize: '11px'}
//     });

//     var legendItem = ui.Panel({
//       widgets: [colorBox, description],
//       layout: ui.Panel.Layout.Flow('horizontal')
//     });

//     speciesLegend.add(legendItem);
//   });

//   // Add species legend panel to the UI after it's populated
//   ui.root.add(speciesLegend);
// });



//////////////////////
///
///
/// Charting to cross compare EO, be sure to bound the temporal resolution when using
///
///
//////////////////////




// // Create 100 random sample points within the geometry
// var samples = ee.FeatureCollection.randomPoints({
//   region: geometry,
//   points: 100,
//   seed: 42
// });

// // Sample NDVI values from each image
// var lsSamples = ls_image.select('NDVI').sampleRegions({
//   collection: samples,
//   scale: 30,
//   geometries: true
// }).map(function(f) { return f.set('source', 'Landsat') });

// var s2Samples = s2_image.select('NDVI').sampleRegions({
//   collection: samples,
//   scale: 10,
//   geometries: true
// }).map(function(f) { return f.set('source', 'Sentinel2') });

// var naipSamples = NAIP_image.select('NDVI').sampleRegions({
//   collection: samples,
//   scale: 1,
//   geometries: true
// }).map(function(f) { return f.set('source', 'NAIP') });

// // Join all NDVI values by location using the sample point geometry
// var joined = samples.map(function(pt) {
//   var ls = ls_image.reduceRegion({
//     reducer: ee.Reducer.mean(),
//     geometry: pt.geometry(),
//     scale: 30
//   }).get('NDVI');

//   var s2 = s2_image.reduceRegion({
//     reducer: ee.Reducer.mean(),
//     geometry: pt.geometry(),
//     scale: 10
//   }).get('NDVI');

//   var naip = NAIP_image.reduceRegion({
//     reducer: ee.Reducer.mean(),
//     geometry: pt.geometry(),
//     scale: 1
//   }).get('NDVI');

//   return pt.set({
//     'NDVI_LS': ls,
//     'NDVI_S2': s2,
//     'NDVI_NAIP': naip
//   });
// });

// // Filter out points with any nulls
// var clean = joined.filter(ee.Filter.notNull(['NDVI_LS', 'NDVI_S2', 'NDVI_NAIP']));
// print("Sample points with all NDVI values:", clean.limit(5));

// // Compute R² between Landsat & Sentinel-2 NDVI
// var chartLSvsS2 = ui.Chart.feature.byFeature(clean, 'NDVI_LS', ['NDVI_S2'])
//   .setChartType('ScatterChart')
//   .setOptions({
//     title: 'Landsat NDVI vs Sentinel-2 NDVI',
//     hAxis: {title: 'Landsat NDVI'},
//     vAxis: {title: 'Sentinel-2 NDVI'},
//     trendlines: {0: {
//       showR2: true,
//       visibleInLegend: true
//     }},
//     pointSize: 4
//   });

// print(chartLSvsS2);

// // Compute R² between Landsat & NAIP NDVI
// var chartLSvsNAIP = ui.Chart.feature.byFeature(clean, 'NDVI_LS', ['NDVI_NAIP'])
//   .setChartType('ScatterChart')
//   .setOptions({
//     title: 'Landsat NDVI vs NAIP NDVI',
//     hAxis: {title: 'Landsat NDVI'},
//     vAxis: {title: 'NAIP NDVI'},
//     trendlines: {0: {
//       showR2: true,
//       visibleInLegend: true
//     }},
//     pointSize: 4
//   });

// print(chartLSvsNAIP);

// // Compute R² between Sentinel-2 & NAIP NDVI
// var chartS2vsNAIP = ui.Chart.feature.byFeature(clean, 'NDVI_S2', ['NDVI_NAIP'])
//   .setChartType('ScatterChart')
//   .setOptions({
//     title: 'Sentinel-2 NDVI vs NAIP NDVI',
//     hAxis: {title: 'Sentinel-2 NDVI'},
//     vAxis: {title: 'NAIP NDVI'},
//     trendlines: {0: {
//       showR2: true,
//       visibleInLegend: true
//     }},
//     pointSize: 4
//   });

// print(chartS2vsNAIP);


// // Turn NDVI triples into FeatureCollection for charting all pairs in one chart
// var ls_s2_pairs = clean.map(function(f) {
//   return ee.Feature(null, {
//     x: f.get('NDVI_LS'),
//     y: f.get('NDVI_S2'),
//     pair: 'Landsat vs Sentinel-2'
//   });
// });

// var ls_naip_pairs = clean.map(function(f) {
//   return ee.Feature(null, {
//     x: f.get('NDVI_LS'),
//     y: f.get('NDVI_NAIP'),
//     pair: 'Landsat vs NAIP'
//   });
// });

// var s2_naip_pairs = clean.map(function(f) {
//   return ee.Feature(null, {
//     x: f.get('NDVI_S2'),
//     y: f.get('NDVI_NAIP'),
//     pair: 'Sentinel-2 vs NAIP'
//   });
// });

// // Combine into a single FeatureCollection
// var combinedPairs = ls_s2_pairs.merge(ls_naip_pairs).merge(s2_naip_pairs);

// // Create the multi-series scatter chart with trendlines and R² values
// var combinedChart = ui.Chart.feature.groups({
//   features: combinedPairs,
//   xProperty: 'x',
//   yProperty: 'y',
//   seriesProperty: 'pair'
// })
// .setChartType('ScatterChart')
// .setOptions({
//   title: 'NDVI Comparisons: Landsat, Sentinel-2, NAIP',
//   hAxis: {title: 'NDVI Source A'},
//   vAxis: {title: 'NDVI Source B'},
//   pointSize: 4,
//   trendlines: {
//     0: { showR2: true, visibleInLegend: true },
//     1: { showR2: true, visibleInLegend: true },
//     2: { showR2: true, visibleInLegend: true }
//   },
//   series: {
//     0: { color: 'blue' },
//     1: { color: 'green' },
//     2: { color: 'red' }
//   },
//   legend: { position: 'bottom' }
// });

// print(combinedChart);
